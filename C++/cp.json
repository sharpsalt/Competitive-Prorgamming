{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	
  "CP": {
  "prefix": "CP",
  "body": [
    "#include \"bits/stdc++.h\"",
    "#include \"ext/pb_ds/assoc_container.hpp\"",
    "#include \"ext/pb_ds/tree_policy.hpp\"",
    "using namespace std;",
    "using namespace __gnu_pbds;",
    "using ll = long long;",
    "using ld = long double;",
    "",
    "typedef vector<int> vi;",
    "typedef pair<int,int> pii;",
    "typedef pair<pii,int> ppi;",
    "typedef vector<pii> vpi;",
    "typedef vector<ppi> vppi;",
    "typedef map<int,int> mii;",
    "typedef map<int,vi> mvi;",
    "typedef map<pii,int> mpi;",
    "",
    "// Fast IO-FastIO , M25-Min_25 , Dinic Flow-DinicFlow , Fast Factorize-FFactorize , Brent Factor-BrentFactor , X-Dictionary-XDict",
    "// Beginner FastIO-BFastIO , Pragmas-Prgama , Z-Algorithm-Z-Algorithm , Z-Function-Z-Func , Modular Integer-modular_int ",
    "// GP_Hash_Table-gp_hash , Segment Tree with Point(Adv)-SegPoint Adv, Segment Tree with Point(Basic)-SegPoint Basic",
    "",
    "",
    "const int INF = 1e9 + 7;",
    "const ll LLINF = 1e18;",
    "const ld EPS = 1e-9;",
    "const ld PI = acos(-1.0);",
    "// const double PI=3.14159265358979323846264338327950288419716939937510582097494459230;",
    "",
    "template<class T> ",
    "using ordered_set = tree<T, null_type,less<T>, rb_tree_tag, tree_order_statistics_node_update> ;",
    " ",
    "template<class key, class value, class cmp = std::less<key>>",
    "using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;",
    "// find_by_order(k)  returns iterator to kth element starting from 0;",
    "// order_of_key(k) returns count of elements strictly smaller than k;",
    " ",
    "template<class T>",
    "using min_heap = priority_queue<T,vector<T>,greater<T> >;",
    "",
    "/*/---------------------------IO(Debugging)----------------------/*/",
    " ",
    "template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ",
    "istream& operator >> (istream &is, T_container &v) { ",
    "   for(T &x : v) is >> x; return is;",
    "}",
    "#ifdef __SIZEOF_INT128__",
    "ostream& operator << (ostream &os, __int128 const& value){",
    "    static char buffer[64];",
    "    int index = 0;",
    "    __uint128_t T = (value < 0) ? (-(value + 1)) + __uint128_t(1) : value;",
    "    if (value < 0) ",
    "        os << '-';",
    "    else if (T == 0)",
    "        return os << '0';",
    "    for(; T > 0; ++index){",
    "        buffer[index] = static_cast<char>('0' + (T % 10));",
    "        T /= 10;",
    "    }    ",
    "    while(index > 0)",
    "        os << buffer[--index];",
    "    return os;",
    "}",
    "istream& operator >> (istream& is, __int128& T){",
    "    static char buffer[64];",
    "    is >> buffer;",
    "    size_t len = strlen(buffer), index = 0;",
    "    T = 0; int mul = 1;",
    "    if (buffer[index] == '-')",
    "        ++index, mul *= -1;",
    "    for(; index < len; ++index)",
    "        T = T * 10 + static_cast<int>(buffer[index] - '0');",
    "    T *= mul;    ",
    "    return is;",
    "}",
    "#endif",
    "",
    "template<typename A, typename B> ",
    "ostream& operator<<(ostream &os, const pair<A, B> &p) { ",
    "   return os << '(' << p.first << \", \" << p.second << ')'; ",
    "}",
    " ",
    "template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ",
    "ostream& operator << (ostream &os, const T_container &v) { ",
    "   os << '{'; string sep; ",
    "   for (const T &x : v) os << sep << x, sep = \", \"; ",
    "   return os << '}'; ",
    "}",
    "template<class P, class Q = vector<P>, class R = less<P> > ostream& operator << (ostream& out, priority_queue<P, Q, R> const& M){",
    "    static priority_queue<P, Q, R> U;",
    "    U = M;",
    "    out << \"{ \";",
    "    while(!U.empty())",
    "        out << U.top() << \" \", U.pop();",
    "    return (out << \"}\");",
    "}",
    "template<class P> ostream& operator << (ostream& out, queue<P> const& M){",
    "    static queue<P> U;",
    "    U = M;",
    "    out << \"{\"; string sep;",
    "    while(!U.empty()){",
    "        out << sep << U.front(); sep = \", \"; U.pop();",
    "    }",
    "    return (out << \"}\");",
    "}",
    "",
    "/*/---------------------------RNG----------------------/*/",
    "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
    "inline int64_t random_long(long long l = LLONG_MIN,long long r = LLONG_MAX){",
    "    uniform_int_distribution<int64_t> generator(l,r);",
    "    return generator(rng);",
    "}",
    "struct custom_hash { // Credits: https://codeforces.com/blog/entry/62393",
    "    static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c",
    "        x += 0x9e3779b97f4a7c15;",
    "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
    "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
    "        return x ^ (x >> 31);",
    "    }",
    "    size_t operator()(uint64_t x) const {",
    "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
    "        return splitmix64(x + FIXED_RANDOM);",
    "    }",
    "    template<typename L, typename R>",
    "    size_t operator()(pair<L,R> const& Y) const{",
    "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
    "        return splitmix64(Y.first * 31ull + Y.second + FIXED_RANDOM);",
    "    }",
    "};",
    "",
    "/*/--------------------------Debugger----------------------/*/",
    "#define TRACE",
    "#ifdef TRACE",
    "    #define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)",
    "    template <typename Arg1>",
    "    void __f(const char* name, Arg1&& arg1){",
    "        cerr << name << \" : \" << arg1 << endl;",
    "    }",
    "    template <typename Arg1, typename... Args>",
    "    void __f(const char* names, Arg1&& arg1, Args&&... args){",
    "         int count_open = 0, len = 1;",
    "         for(int k = 1; ; ++k){",
    "            char cur = *(names + k);",
    "            count_open += (cur == '(' ? 1 : (cur == ')' ? -1: 0));",
    "            if (cur == ',' && count_open == 0){",
    "               const char* comma = names + k;",
    "               cerr.write(names, len) << \" : \" << arg1 << \" | \";",
    "               __f(comma + 1, args...);",
    "               return;",
    "            }",
    "            len = (cur == ' ' ? len : k + 1);",
    "         }",
    "    }",
    "#else",
    "    #define trace(...) 1",
    "#endif",
    " ",
    " ",
    "/*/---------------------------Defines----------------------/*/",
    "#define rep3(i, a, b, j) for(int i = a; i < b; i += j)",
    "#define rep2(i, a, b) rep3(i, a, b, 1)",
    "#define rep1(i, a) rep2(i, 0, a)",
    "#define GET_MACRO(_1, _2, _3, NAME, ...) NAME",
    "#define rep(...) GET_MACRO(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)",
    "#define REPR(i,a, b) for (int i=(a);i>=(b);--i)",
    "#define all(x) (x).begin(),(x).end()",
    "#define sz(x) ((int)(x).size())",
    "#define msb(mask) (63-__builtin_clzll(mask))  /// 0 -> -1",
    "#define lsb(mask) __builtin_ctzll(mask)  /// 0 -> 64",
    "#define lusb(mask) __builtin_ctzll(~(mask))",
    "#define cntsetbit(mask) __builtin_popcountll(mask)",
    "#define checkbit(mask,bit) ((mask >> bit) & 1ll)",
    "#define onbit(mask,bit) ((mask)|(1LL<<(bit)))",
    "#define offbit(mask,bit) ((mask)&~(1LL<<(bit)))",
    "#define changebit(mask,bit) ((mask)^(1LL<<bit))",
    "#define pb push_back",
    "#define mp make_pair",
    "#define fi first",
    "#define se second",
    "#define endl \"\\n\"",
    "#define d0(x) cout<<(x)<<\" \"",
    "#define d1(x) cout<<(x)<<endl",
    "#define d2(x,y) cout<<(x)<<\" \"<<(y)<<endl",
    "#define d3(x,y,z) cout<<(x)<<\" \"<<(y)<<\" \"<<(z)<<endl",
    "#define d4(a,b,c,d) cout<<(a)<<\" \"<<(b)<<\" \"<<(c)<<\" \"<<(d)<<endl",
    "#define d5(a,b,c,d,e) cout<<(a)<<\" \"<<(b)<<\" \"<<(c)<<\" \"<<(d)<<\" \"<<(e)<<endl",
    "#define d6(a,b,c,d,e,f) cout<<(a)<<\" \"<<(b)<<\" \"<<(c)<<\" \"<<(d)<<\" \"<<(e)<<\" \"<<(f)<<endl",
    "",
    "// #define int long long or use int64_t based on usecase",
    "//if it is integer overflow use pyhton plz",
    "//Read the Qn Properly, your logic is always correct",
    "",
    "",
    "//Uncomment it if it is Single Test",
    "// #define SINGLE_TEST",
    "",
    "void solve()",
    "{",
    "  //Be Careful while solving Questions",
    "}",
    "",
    "int main() {",
    "    // Use \"set_name\".max_load_factor(0.25f);\"set_name\".reserve(512); with unordered set",
    "    // Or use gp_hash_table<X,null_type>",
    "    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);",
    "    cout << fixed << setprecision(25);",
    "    cerr << fixed << setprecision(10);",
    "    // freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);",
    "    auto start = std::chrono::high_resolution_clock::now();",
    "    int t = 1;",
    "    #ifndef SINGLE_TEST",
    "        cin >> t;",
    "    #endif",
    "    while (t--) {",
    "        solve();",
    "    }",
    "",
    "    auto stop = std::chrono::high_resolution_clock::now(); ",
    "    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start);",
    "    // cerr << \"Time taken : \" << ((long double)duration.count())/((long double) 1e9) <<\"s \"<< endl;     ",
    "    return 0;",
    "}"
  ],
  "description": "Use it For CP"
},
"LeetCode": {
  "prefix": "LC",
  "body": [
    "#include \"bits/stdc++.h\"",
    "#include \"ext/pb_ds/assoc_container.hpp\"",
    "#include \"ext/pb_ds/tree_policy.hpp\"",
    "using namespace std;",
    "using namespace __gnu_pbds;",
    "using ll = long long;",
    "using ld = long double;",
    "",
    "typedef vector<int> vi;",
    "typedef pair<int,int> pii;",
    "typedef pair<pii,int> ppi;",
    "typedef vector<pii> vpi;",
    "typedef vector<ppi> vppi;",
    "typedef map<int,int> mii;",
    "typedef map<int,vi> mvi;",
    "typedef map<pii,int> mpi;",
    "",
    "",
    "const int INF = 1e9 + 7;",
    "const ll LLINF = 1e18;",
    "const ld EPS = 1e-9;",
    "const ld PI = acos(-1.0);",
    "// const double PI=3.14159265358979323846264338327950288419716939937510582097494459230;",
    "",
    "template<class T> ",
    "using ordered_set = tree<T, null_type,less<T>, rb_tree_tag, tree_order_statistics_node_update> ;",
    " ",
    "template<class key, class value, class cmp = std::less<key>>",
    "using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;",
    "// find_by_order(k)  returns iterator to kth element starting from 0;",
    "// order_of_key(k) returns count of elements strictly smaller than k;",
    " ",
    "template<class T>",
    "using min_heap = priority_queue<T,vector<T>,greater<T> >;",
    "",
    "/*/---------------------------IO(Debugging)----------------------/*/",
    " ",
    "template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ",
    "istream& operator >> (istream &is, T_container &v) { ",
    "   for(T &x : v) is >> x; return is;",
    "}",
    "#ifdef __SIZEOF_INT128__",
    "ostream& operator << (ostream &os, __int128 const& value){",
    "    static char buffer[64];",
    "    int index = 0;",
    "    __uint128_t T = (value < 0) ? (-(value + 1)) + __uint128_t(1) : value;",
    "    if (value < 0) ",
    "        os << '-';",
    "    else if (T == 0)",
    "        return os << '0';",
    "    for(; T > 0; ++index){",
    "        buffer[index] = static_cast<char>('0' + (T % 10));",
    "        T /= 10;",
    "    }    ",
    "    while(index > 0)",
    "        os << buffer[--index];",
    "    return os;",
    "}",
    "istream& operator >> (istream& is, __int128& T){",
    "    static char buffer[64];",
    "    is >> buffer;",
    "    size_t len = strlen(buffer), index = 0;",
    "    T = 0; int mul = 1;",
    "    if (buffer[index] == '-')",
    "        ++index, mul *= -1;",
    "    for(; index < len; ++index)",
    "        T = T * 10 + static_cast<int>(buffer[index] - '0');",
    "    T *= mul;    ",
    "    return is;",
    "}",
    "#endif",
    "",
    "template<typename A, typename B> ",
    "ostream& operator<<(ostream &os, const pair<A, B> &p) { ",
    "   return os << '(' << p.first << \", \" << p.second << ')'; ",
    "}",
    " ",
    "template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ",
    "ostream& operator << (ostream &os, const T_container &v) { ",
    "   os << '{'; string sep; ",
    "   for (const T &x : v) os << sep << x, sep = \", \"; ",
    "   return os << '}'; ",
    "}",
    "template<class P, class Q = vector<P>, class R = less<P> > ostream& operator << (ostream& out, priority_queue<P, Q, R> const& M){",
    "    static priority_queue<P, Q, R> U;",
    "    U = M;",
    "    out << \"{ \";",
    "    while(!U.empty())",
    "        out << U.top() << \" \", U.pop();",
    "    return (out << \"}\");",
    "}",
    "template<class P> ostream& operator << (ostream& out, queue<P> const& M){",
    "    static queue<P> U;",
    "    U = M;",
    "    out << \"{\"; string sep;",
    "    while(!U.empty()){",
    "        out << sep << U.front(); sep = \", \"; U.pop();",
    "    }",
    "    return (out << \"}\");",
    "}",
    "",
    "/*/---------------------------RNG----------------------/*/",
    "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
    "inline int64_t random_long(long long l = LLONG_MIN,long long r = LLONG_MAX){",
    "    uniform_int_distribution<int64_t> generator(l,r);",
    "    return generator(rng);",
    "}",
    "struct custom_hash { // Credits: https://codeforces.com/blog/entry/62393",
    "    static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c",
    "        x += 0x9e3779b97f4a7c15;",
    "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
    "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
    "        return x ^ (x >> 31);",
    "    }",
    "    size_t operator()(uint64_t x) const {",
    "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
    "        return splitmix64(x + FIXED_RANDOM);",
    "    }",
    "    template<typename L, typename R>",
    "    size_t operator()(pair<L,R> const& Y) const{",
    "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
    "        return splitmix64(Y.first * 31ull + Y.second + FIXED_RANDOM);",
    "    }",
    "};",
    "",
    "/*/--------------------------Debugger----------------------/*/",
    "#define TRACE",
    "#ifdef TRACE",
    "    #define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)",
    "    template <typename Arg1>",
    "    void __f(const char* name, Arg1&& arg1){",
    "        cerr << name << \" : \" << arg1 << endl;",
    "    }",
    "    template <typename Arg1, typename... Args>",
    "    void __f(const char* names, Arg1&& arg1, Args&&... args){",
    "         int count_open = 0, len = 1;",
    "         for(int k = 1; ; ++k){",
    "            char cur = *(names + k);",
    "            count_open += (cur == '(' ? 1 : (cur == ')' ? -1: 0));",
    "            if (cur == ',' && count_open == 0){",
    "               const char* comma = names + k;",
    "               cerr.write(names, len) << \" : \" << arg1 << \" | \";",
    "               __f(comma + 1, args...);",
    "               return;",
    "            }",
    "            len = (cur == ' ' ? len : k + 1);",
    "         }",
    "    }",
    "#else",
    "    #define trace(...) 1",
    "#endif",
    " ",
    " ",
    "/*/---------------------------Defines----------------------/*/",
    "#define rep3(i, a, b, j) for(int i = a; i < b; i += j)",
    "#define rep2(i, a, b) rep3(i, a, b, 1)",
    "#define rep1(i, a) rep2(i, 0, a)",
    "#define GET_MACRO(_1, _2, _3, NAME, ...) NAME",
    "#define rep(...) GET_MACRO(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)",
    "#define REPR(i,a, b) for (int i=(a);i>=(b);--i)",
    "#define all(x) (x).begin(),(x).end()",
    "#define sz(x) ((int)(x).size())",
    "#define pb push_back",
    "#define mp make_pair",
    "#define fi first",
    "#define se second",
    "#define endl \"\\n\"",
    "#define d0(x) cout<<(x)<<\" \"",
    "#define d1(x) cout<<(x)<<endl",
    "#define d2(x,y) cout<<(x)<<\" \"<<(y)<<endl",
    "#define d3(x,y,z) cout<<(x)<<\" \"<<(y)<<\" \"<<(z)<<endl",
    "#define d4(a,b,c,d) cout<<(a)<<\" \"<<(b)<<\" \"<<(c)<<\" \"<<(d)<<endl",
    "#define d5(a,b,c,d,e) cout<<(a)<<\" \"<<(b)<<\" \"<<(c)<<\" \"<<(d)<<\" \"<<(e)<<endl",
    "#define d6(a,b,c,d,e,f) cout<<(a)<<\" \"<<(b)<<\" \"<<(c)<<\" \"<<(d)<<\" \"<<(e)<<\" \"<<(f)<<endl",
    "",
    "// #define int long long or use int64_t based on usecase",
    "//if it is integer overflow use pyhton plz",
    "//Read the Qn Properly, your logic is always correct",
    "",
    "",
    "class Solution{",
    "    public:",
    "        void solve()",
    "        {",
    "           //Start From here",
    "           ",
    "        }",
    "};",
    "",
    "int main() {",
    "    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);",
    "    cout << fixed << setprecision(25);",
    "    cerr << fixed << setprecision(10);",
    "    // freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);",
    "    auto start = std::chrono::high_resolution_clock::now();",
    "    Solution s;",
    "    s.solve();",
    "    auto stop = std::chrono::high_resolution_clock::now(); ",
    "    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start);",
    "    // cerr << \"Time taken : \" << ((long double)duration.count())/((long double) 1e9) <<\"s \"<< endl;     ",
    "    return 0;",
    "}",
    ""
  ],
  "description": "Template For LeetCode"
}
,"FastIO": {
  "prefix": "FastIO",
  "body": [
    "namespace FastIO{ // Adapted from nor (https://github.com/NavneelSinghal/CodeBook/blob/master/misc/io.cpp) and yosupo ",
    "	namespace Internal {",
    "		template<typename T>",
    "		struct internal_get_unsigned{",
    "			typedef typename make_unsigned<T>::type type;",
    "		};",
    "		#ifdef __SIZEOF_INT128__",
    "			template<> struct internal_get_unsigned<__int128>{ ",
    "				typedef __uint128_t type; ",
    "			};",
    "			template<> struct internal_get_unsigned<__uint128_t>{ ",
    "				typedef __uint128_t type; ",
    "			};",
    "		#endif",
    " ",
    "		template <class T>",
    "		struct is_int {",
    "			static constexpr bool value = std::is_integral<T>::value;",
    "		};",
    "		#ifdef __SIZEOF_INT128__",
    "			template <> struct is_int<__int128_t> { static constexpr bool value = true; };",
    "			template <> struct is_int<__uint128_t> { static constexpr bool value = true; };",
    "		#endif",
    " ",
    " ",
    "		template <class T>",
    "		struct is_char {",
    "		    static constexpr bool value = std::is_same<T, char>::value;",
    "		};",
    " ",
    "		template <class T>",
    "		struct is_bool {",
    "		    static constexpr bool value = std::is_same<T, bool>::value;",
    "		};",
    " ",
    "		template <class T>",
    "		struct is_string {",
    "		    static constexpr bool value =",
    "		        std::is_same<T, std::string>::value || std::is_same<T, const char*>::value ||",
    "		        std::is_same<T, char*>::value || std::is_same<std::decay_t<T>, char*>::value;",
    "		    ;",
    "		};",
    " ",
    "		template <class T, class D = void>",
    "		struct is_custom {",
    "		    static constexpr bool value = false;",
    "		};",
    " ",
    "		template <class T>",
    "		struct is_custom<T, std::void_t<typename T::internal_value_type>> {",
    "		    static constexpr bool value = true;",
    "		};",
    " ",
    "		template <class T>",
    "		struct is_default {",
    "		    static constexpr bool value = is_char<T>::value || is_bool<T>::value ||",
    "		                                  is_string<T>::value ||",
    "		                                  is_int<T>::value;",
    "		};",
    " ",
    "		template <class T, class D = void>",
    "		struct is_iterable {",
    "		    static constexpr bool value = false;",
    "		};",
    " ",
    "		template <class T>",
    "		struct is_iterable<",
    "		    T, typename std::void_t<decltype(std::begin(std::declval<T>()))>> {",
    "		    static constexpr bool value = true;",
    "		};",
    " ",
    "		template <class T, class D = void, class E = void>",
    "		struct is_applyable {",
    "		    static constexpr bool value = false;",
    "		};",
    " ",
    "		template <class T>",
    "		struct is_applyable<T, std::void_t<typename std::tuple_size<T>::type>,",
    "		                    std::void_t<decltype(std::get<0>(std::declval<T>()))>> {",
    "		    static constexpr bool value = true;",
    "		};",
    "	};",
    " ",
    "	struct IOPre {",
    "	    static constexpr int TEN = 10, SZ = TEN * TEN * TEN * TEN;",
    "	    std::array<char, 4 * SZ> num;",
    "	    constexpr IOPre() : num{} {",
    "	        for (int i = 0; i < SZ; i++) {",
    "	            int n = i;",
    "	            for (int j = 3; j >= 0; j--) {",
    "	                num[i * 4 + j] = static_cast<char>(n % TEN + '0');",
    "	                n /= TEN;",
    "	            }",
    "	        }",
    "	    }",
    "	};",
    " ",
    "	template<const bool SAFETY_CHECKS>",
    "	struct IO {",
    " ",
    " ",
    "		#if !HAVE_DECL_FREAD_UNLOCKED",
    "			#define fread_unlocked fread",
    "		#endif",
    "		#if !HAVE_DECL_FWRITE_UNLOCKED",
    "			#define fwrite_unlocked fwrite",
    "		#endif",
    "		",
    "		static constexpr int BUFFER_SIZE = 1 << 17, LEN = 64, TEN = 10, HUNDRED = TEN * TEN,",
    "	                         THOUSAND = HUNDRED * TEN, TENTHOUSAND = THOUSAND * TEN,",
    "	                         MAGIC_MULTIPLY = 205, MAGIC_SHIFT = 11, MASK = 15,",
    "	                         TWELVE = 32, SIXTEEN = 36, INTEGER_WIDTH = 64;",
    "	    static constexpr IOPre io_pre = {};",
    " ",
    " ",
    "	    std::array<char, BUFFER_SIZE> input_buffer, output_buffer;",
    "	    int input_start_ptr, input_end_ptr, output_end_ptr;",
    "	    bool end_of_file;",
    " ",
    "	    FILE *read_fptr, *write_fptr;",
    " ",
    "		IO(FILE* read_fp, FILE* write_fp): read_fptr(read_fp), write_fptr(write_fp), input_buffer{}, output_buffer{}, input_start_ptr{}, input_end_ptr{}, output_end_ptr{}, end_of_file(false) {}",
    "		IO(const IO&) = delete;",
    "		IO(IO&&) = delete;",
    "		IO& operator = (const IO&) = delete;",
    "		IO& operator = (const IO&&) = delete;",
    " ",
    "		~IO() {flush();}",
    " ",
    "		template <class T>",
    "	    static constexpr bool needs_newline = (Internal::is_iterable<T>::value ||",
    "	                                           Internal::is_applyable<T>::value) &&",
    "	                                          (!Internal::is_default<T>::value);",
    " ",
    "	    template <typename T, typename U>",
    "	    struct any_needs_newline {",
    "	        static constexpr bool value = false;",
    "	    };",
    "	    template <typename T>",
    "	    struct any_needs_newline<T, std::index_sequence<>> {",
    "	        static constexpr bool value = false;",
    "	    };",
    "	    template <typename T, std::size_t I, std::size_t... Is>",
    "	    struct any_needs_newline<T, std::index_sequence<I, Is...>> {",
    "	        static constexpr bool value =",
    "	            needs_newline<decltype(std::get<I>(std::declval<T>()))> ||",
    "	            any_needs_newline<T, std::index_sequence<Is...>>::value;",
    "	    };",
    " ",
    " ",
    "	    inline bool reload() { // Reloads without already read checks -- add read check for eof in interactive problems?.",
    "	    	if constexpr (SAFETY_CHECKS) {",
    "				assert (input_end_ptr >= input_start_ptr);",
    "			}",
    " ",
    " ",
    "	    	if (input_start_ptr > (BUFFER_SIZE >> 1)) [[unlikely]] {",
    "	    		memmove(std::begin(input_buffer), std::begin(input_buffer) + input_start_ptr, input_end_ptr - input_start_ptr);",
    "	    		input_end_ptr -= input_start_ptr;",
    "	    		input_start_ptr = 0;",
    "	    	}",
    "	    	",
    "	    	if (end_of_file) [[unlikely]]",
    "	    		return false;",
    "			else if (input_end_ptr == BUFFER_SIZE) [[unlikely]]",
    "				return true;",
    " ",
    "	    	size_t read_length = fread_unlocked(std::begin(input_buffer) + input_end_ptr, sizeof(char), BUFFER_SIZE - input_end_ptr, read_fptr);",
    " ",
    "	    	if (read_length == 0) {",
    "	    		end_of_file = true;",
    "	    		input_buffer[input_end_ptr] = '\\0';",
    "	    		read_length = 1;",
    "	    	}",
    "	    	input_end_ptr += read_length;",
    "	  		return true;",
    "	    }",
    " ",
    "	    inline bool read_char(char& c) {",
    "	    	if (input_start_ptr == input_end_ptr) [[unlikely]]{",
    "	    		if (!reload())",
    "	    			return false;",
    "	    	}",
    "			c = input_buffer[input_start_ptr++];    	",
    "			return true;",
    "	    }",
    " ",
    "	    inline bool read_string(std::string& s) {",
    "	    	while (true) {",
    "	    		while (input_start_ptr < input_end_ptr && input_buffer[input_start_ptr] <= ' ') ++input_start_ptr;",
    "	    		if (input_start_ptr < input_end_ptr)",
    "	    			break;",
    "	    		if (!reload())",
    "	    			return false;",
    "	    	}",
    "	    	s.clear();",
    "	    	char x;",
    "	    	while (true) {",
    "	    		if (!read_char(x) || x <= ' ') // read_char will always be true?",
    "	    			break;",
    "	    		s += x;",
    "	    	}",
    "	    	return !s.empty();",
    "	    }",
    " ",
    "	    template <class T>",
    "	    inline typename std::enable_if<std::is_floating_point<T>::value, bool>::type read_float(T& x) { // No custom implementation -- maybe even slower.",
    "			std::string s;",
    "	        if (!read_string(s)) return false;",
    "	        x = std::stold(s); ",
    "	        return true;",
    "	    }",
    " ",
    "	    template <class T>",
    "	    inline typename std::enable_if<Internal::is_int<T>::value, bool>::type read_int(T& x) {",
    "	    	using U = typename Internal::internal_get_unsigned<T>::type;",
    " ",
    "	    	while (true) {",
    "	    		while (input_start_ptr < input_end_ptr && input_buffer[input_start_ptr] < '-') ++input_start_ptr;",
    "	    		if (input_start_ptr < input_end_ptr)",
    "	    			break;",
    "	    		if (!reload())",
    "	    			return false;",
    "	    	}",
    " ",
    "	    	if (input_start_ptr + INTEGER_WIDTH > input_end_ptr) [[unlikely]]{",
    "	    		reload();",
    "	    	}",
    " ",
    "	    	if (input_start_ptr == input_end_ptr) [[unlikely]]{",
    "	    		return false;",
    "	    	}",
    "	    	bool minus = false;",
    "	    	if (input_buffer[input_start_ptr] == '-') {",
    "	    		minus = true;",
    "	    		++input_start_ptr;",
    "	    	}",
    " ",
    "	    	x = 0;",
    "	    	char c;",
    "	    	while (input_start_ptr < input_end_ptr) {",
    "	    		c = input_buffer[input_start_ptr];",
    "	    		if (c < '0' || c > '9') {",
    "	    			break;",
    "	    		}",
    "	    		++input_start_ptr;",
    "	    		x = x * TEN + (c & MASK);",
    "	    	}",
    "	    	if (minus) x = -x;",
    "	    	return true;",
    "	    }",
    "		inline void flush() {",
    "	        fwrite_unlocked(std::begin(output_buffer), sizeof(char), output_end_ptr, write_fptr);",
    "	        output_end_ptr = 0;",
    "	    }",
    " ",
    "	    template <typename T>",
    "	    IO& operator >> (T& x) {",
    "	        static_assert(Internal::is_custom<T>::value or Internal::is_default<T>::value or",
    "	                      Internal::is_iterable<T>::value or Internal::is_applyable<T>::value or is_floating_point<T>::value);",
    "	        static_assert(!Internal::is_bool<T>::value);",
    "	        bool was_read = false;",
    "	        if constexpr (Internal::is_custom<T>::value) {",
    "	            typename T::internal_value_type y;",
    "	            was_read = read_int(y);",
    "	            x = y;",
    "	        } else if constexpr (Internal::is_default<T>::value) {",
    "	            if constexpr (Internal::is_string<T>::value) {",
    "	                was_read = read_string(x);",
    "	            } else if constexpr (Internal::is_char<T>::value) {",
    "	                was_read =read_char(x);",
    "	            } else if constexpr (Internal::is_int<T>::value) {",
    "	                was_read = read_int(x);",
    "	            }",
    "	        } ",
    "	        else if constexpr (is_floating_point<T>::value) {",
    "            	was_read = read_float(x);",
    "            }",
    "	        else if constexpr (Internal::is_iterable<T>::value) {",
    "	            for (auto& y : x) operator>>(y);",
    "	        } else if constexpr (Internal::is_applyable<T>::value) {",
    "	            std::apply([this](auto&... y) { ((this->operator>>(y)), ...); }, x);",
    "	        }",
    " ",
    "	        if constexpr (SAFETY_CHECKS and (Internal::is_custom<T>::value or Internal::is_default<T>::value or is_floating_point<T>::value)) {",
    "	        	assert (was_read);",
    "	        }",
    "	        return *this;",
    "	    }",
    " ",
    "	    inline void write_char(char c) {",
    "	        if (output_end_ptr == BUFFER_SIZE) [[unlikely]] flush();",
    "	        output_buffer[output_end_ptr++] = c;",
    "	    }",
    " ",
    "	    inline void write_bool(bool b) {",
    "	        if (output_end_ptr == BUFFER_SIZE) [[unlikely]] flush();",
    "	        output_buffer[output_end_ptr++] = b ? '1' : '0';",
    "	    }",
    " ",
    "	    inline void write_string(const std::string& s) {",
    "	        for (const auto& x : s) write_char(x);",
    "	    }",
    " ",
    "	    inline void write_string(const char* s) {",
    "	        while (*s) write_char(*s++);",
    "	    }",
    " ",
    "	    inline void write_string(char* s) {",
    "	        while (*s) write_char(*s++);",
    "	    }",
    " ",
    "	    template <typename T>",
    "	    inline typename std::enable_if<Internal::is_int<T>::value, void>::type write_int(const T& y) {",
    "	    	using U = typename Internal::internal_get_unsigned<T>::type;",
    " ",
    "	        if (output_end_ptr > BUFFER_SIZE - INTEGER_WIDTH) flush();",
    "	        if (!y) {",
    "	            output_buffer[output_end_ptr++] = '0';",
    "	            return;",
    "	        }",
    "	        U x = y;",
    "	        if (y < 0) output_buffer[output_end_ptr++] = '-', x = -y;",
    "	        int i = TWELVE;",
    "	        static std::array<char, SIXTEEN> buf{};",
    "	        while (x >= TENTHOUSAND) {",
    "	            memcpy(std::begin(buf) + i,",
    "	                   std::begin(io_pre.num) + (x % TENTHOUSAND) * 4, 4);",
    "	            x /= TENTHOUSAND;",
    "	            i -= 4;",
    "	        }",
    "	        if (x < HUNDRED) {",
    "	            if (x < TEN) {",
    "	                output_buffer[output_end_ptr++] = static_cast<char>('0' + x);",
    "	            } else {",
    "	                std::uint32_t q =",
    "	                    (static_cast<std::uint32_t>(x) * MAGIC_MULTIPLY) >>",
    "	                    MAGIC_SHIFT;",
    "	                std::uint32_t r = static_cast<std::uint32_t>(x) - q * TEN;",
    "	                output_buffer[output_end_ptr] = static_cast<char>('0' + q);",
    "	                output_buffer[output_end_ptr + 1] =",
    "	                    static_cast<char>('0' + r);",
    "	                output_end_ptr += 2;",
    "	            }",
    "	        } else {",
    "	            if (x < THOUSAND) {",
    "	                memcpy(std::begin(output_buffer) + output_end_ptr,",
    "	                       std::begin(io_pre.num) + (x << 2) + 1, 3),",
    "	                    output_end_ptr += 3;",
    "	            } else {",
    "	                memcpy(std::begin(output_buffer) + output_end_ptr,",
    "	                       std::begin(io_pre.num) + (x << 2), 4),",
    "	                    output_end_ptr += 4;",
    "	            }",
    "	        }",
    "	        memcpy(std::begin(output_buffer) + output_end_ptr,",
    "	               std::begin(buf) + i + 4, TWELVE - i);",
    "	        output_end_ptr += TWELVE - i;",
    "	    }",
    " ",
    "	    template <typename T_>",
    "	    IO& operator << (T_&& x) {",
    "	        using T = typename std::remove_cv<",
    "	            typename std::remove_reference<T_>::type>::type;",
    "	        static_assert(Internal::is_custom<T>::value or Internal::is_default<T>::value or",
    "	                      Internal::is_iterable<T>::value or Internal::is_applyable<T>::value);",
    "	        if constexpr (Internal::is_custom<T>::value) {",
    "	            write_int(x.get());",
    "	        } else if constexpr (Internal::is_default<T>::value) {",
    "	            if constexpr (Internal::is_bool<T>::value) {",
    "	                write_bool(x);",
    "	            } else if constexpr (Internal::is_string<T>::value) {",
    "	                write_string(x);",
    "	            } else if constexpr (Internal::is_char<T>::value) {",
    "	                write_char(x);",
    "	            } else if constexpr (Internal::is_int<T>::value) {",
    "	                write_int(x);",
    "	            }",
    "	        } else if constexpr (Internal::is_iterable<T>::value) {",
    "	            // strings are immune",
    "	            using E = decltype(*std::begin(x));",
    "	            constexpr char sep = needs_newline<E> ? '\\n' : ' ';",
    "	            int i = 0;",
    "	            for (const auto& y : x) {",
    "	                if (i++) write_char(sep);",
    "	                operator<<(y);",
    "	            }",
    "	        } else if constexpr (Internal::is_applyable<T>::value) {",
    "	            // strings are immune",
    "	            constexpr char sep =",
    "	                (any_needs_newline<",
    "	                    T, std::make_index_sequence<std::tuple_size_v<T>>>::value)",
    "	                    ? '\\n'",
    "	                    : ' ';",
    "	            int i = 0;",
    "	            std::apply(",
    "	                [this, &sep, &i](auto const&... y) {",
    "	                    (((i++ ? write_char(sep) : void()), this->operator<<(y)),",
    "	                     ...);",
    "	                },",
    "	                x);",
    "	        }",
    "	        return *this;",
    "	    }",
    "	    IO& operator << (IO<SAFETY_CHECKS>& (*func)(IO<SAFETY_CHECKS>&)) {",
    "	    	return func(*this);",
    "	    }",
    "	    IO* tie(std::nullptr_t) { return this; }",
    "	    inline void sync_with_stdio(bool) {}",
    "	};",
    "	IO<false> Io(stdin, stdout);",
    " ",
    "	template <const bool SAFETY_CHECKS>",
    "	FastIO::IO<SAFETY_CHECKS>& endl (FastIO::IO<SAFETY_CHECKS>& os){",
    "		os.write_char('\\n');",
    "		os.flush();",
    "		return os;",
    "	}",
    " ",
    "	#define cin FastIO::Io",
    "	#define cout FastIO::Io",
    " ",
    "};",
    "using FastIO::endl"
  ],
  "description": "Use it for FastIO"
}
,
"Min_25": {
  "prefix": "Min_25_Sieve",
  "body": [
    "vector<int> sieve(const int N, const int Q = 17, const int L = 1 << 15) {",
    "    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};",
    "    struct P { ",
    "        P(int p) : p(p) {}",
    "        int p; int pos[8];",
    "    };",
    "    auto approx_prime_count = [] (const int N) -> int {",
    "        return N > 60184 ? N / (log(N) - 1.1)",
    "                         : max(1., N / (log(N) - 1.11)) + 1;",
    "    };",
    "",
    "    const int v = sqrt(N), vv = sqrt(v);",
    "    vector<bool> isp(v + 1, true);",
    "    for (int i = 2; i <= vv; ++i) if (isp[i]) {",
    "        for (int j = i * i; j <= v; j += i) isp[j] = false;",
    "    }",
    "",
    "    const int rsize = approx_prime_count(N + 30);",
    "    vector<int> primes = {2, 3, 5}; int psize = 3;",
    "    primes.resize(rsize);",
    "",
    "    vector<P> sprimes; size_t pbeg = 0;",
    "    int prod = 1; ",
    "    for (int p = 7; p <= v; ++p) {",
    "        if (!isp[p]) continue;",
    "        if (p <= Q) prod *= p, ++pbeg, primes[psize++] = p;",
    "        auto pp = P(p); ",
    "        for (int t = 0; t < 8; ++t) {",
    "            int j = (p <= Q) ? p : p * p;",
    "            while (j % 30 != rs[t]) j += p << 1;",
    "            pp.pos[t] = j / 30;",
    "        }",
    "        sprimes.push_back(pp);",
    "    }",
    "",
    "    vector<unsigned char> pre(prod, 0xFF);",
    "    for (size_t pi = 0; pi < pbeg; ++pi) {",
    "        auto pp = sprimes[pi]; const int p = pp.p;",
    "        for (int t = 0; t < 8; ++t) {",
    "            const unsigned char m = ~(1 << t);",
    "            for (int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;",
    "        }",
    "    }",
    "",
    "    const int block_size = (L + prod - 1) / prod * prod;",
    "    vector<unsigned char> block(block_size); unsigned char* pblock = block.data();",
    "    const int M = (N + 29) / 30;",
    "",
    "    for (int beg = 0; beg < M; beg += block_size, pblock -= block_size) {",
    "        int end = min(M, beg + block_size);",
    "        for (int i = beg; i < end; i += prod) {",
    "            copy(pre.begin(), pre.end(), pblock + i);",
    "        }",
    "        if (beg == 0) pblock[0] &= 0xFE;",
    "        for (size_t pi = pbeg; pi < sprimes.size(); ++pi) {",
    "            auto& pp = sprimes[pi];",
    "            const int p = pp.p;",
    "            for (int t = 0; t < 8; ++t) {",
    "                int i = pp.pos[t]; const unsigned char m = ~(1 << t);",
    "                for (; i < end; i += p) pblock[i] &= m;",
    "                pp.pos[t] = i;",
    "            }",
    "        }",
    "        for (int i = beg; i < end; ++i) {",
    "            for (int m = pblock[i]; m > 0; m &= m - 1) {",
    "                primes[psize++] = i * 30 + rs[__builtin_ctz(m)];",
    "            }",
    "        }",
    "    }",
    "    assert(psize <= rsize);",
    "    while (psize > 0 && primes[psize - 1] > N) --psize;",
    "    primes.resize(psize);",
    "    return primes;",
    "}"
  ],
  "description": "Use it for Fast Sieve"
},
"DinicFlow": {
  "prefix": "DinicFLow",
  "body": [
    "#define vll vector<long long>",
    "",
    "struct edge {ll x, y, cap, flow;};",
    "struct DinicFlow {",
    "    // *** change inf accordingly *****",
    "    const ll inf = (1e18);",
    "    vector <edge> e; vll cur, d;",
    "    vector<vll> adj; ll n, source, sink;",
    "    DinicFlow() {}",
    "    DinicFlow(ll v){ n=v; cur=vll(n+1);",
    "        d = vll(n+1); adj = vector<vll>(n+1);}",
    "    void addEdge(ll from, ll to, ll cap) {",
    "        edge e1 = {from, to, cap, 0};",
    "        edge e2 = {to, from, 0, 0}; ",
    "        adj[from].pb(e.size()); e.pb(e1);",
    "        adj[to].pb(e.size()); e.pb(e2); }",
    "    ll bfs(){ queue <ll> q;",
    "        for(ll i = 0; i <= n; ++i) d[i] = -1;",
    "        q.push(source); d[source] = 0;",
    "        while(!q.empty() and d[sink] < 0) {",
    "            ll x = q.front(); q.pop();",
    "            for(ll i = 0; i < (ll)adj[x].size(); ++i){",
    "                ll id = adj[x][i], y = e[id].y;",
    "                if(d[y]<0 and e[id].flow < e[id].cap){",
    "                    q.push(y); d[y] = d[x] + 1;",
    "        } } } return d[sink] >= 0; }",
    "    ll dfs(ll x, ll flow) { if(!flow) return 0;",
    "        if(x == sink) return flow;",
    "        for(;cur[x] < (ll)adj[x].size(); ++cur[x]){",
    "            ll id = adj[x][cur[x]], y = e[id].y;",
    "            if(d[y] != d[x] + 1) continue;",
    "            ll pushed = dfs(y,min(flow,e[id].cap-e[id].flow));",
    "            if(pushed){ e[id].flow+=pushed; ",
    "                e[id^1].flow -= pushed; return pushed; }",
    "        } return 0; }",
    "    ll maxFlow(ll src, ll snk) {",
    "        this->source=src;this->sink = snk; ll flow=0;",
    "        while(bfs()){ for(ll i=0;i<=n;++i) cur[i]=0;",
    "         while(ll pushed=dfs(source,inf))flow+=pushed;",
    "        } return flow;",
    "} };",
    ""
  ],
  "description": "Dinic Flow Algorithm"
},
"ReadSignedUnsigned": {
  "prefix": "ReadUnsignedSigned",
  "body": [
    "template<class T>",
    "void readu(T& a) {",
    "	char c; do c = getchar(); while (!isdigit(c)); a = c & 15;",
    "	for (;;) {c = getchar(); if (!isdigit(c)) break; a = a * 10 + (c & 15);}",
    "}",
    "template<class T>",
    "void readi(T& a) {",
    "	char c; bool n = false; do c = getchar(); while (!isdigit(c) && c != '-');",
    "	if (c == '-') n = true, c = getchar(); a = c & 15;",
    "	for (;;) {c = getchar(); if (!isdigit(c)) break; a = a * 10 + (c & 15);}",
    "	if (n) a = -a;",
    "}"
  ],
  "description": "Use it for Reading Signed and Unsigned Integers"
}
,
"FastFactorize": {
  "prefix": "FFactorize",
  "body": [
    "using u8 = uint8_t;",
    "using u16 = uint16_t;",
    "using u64 = uint64_t;",
    "using u128 = __uint128_t; // Only supported in GCC/Clang",
    "",
    "// factorize large integers (up to around 2^62 ≈ 4.6e18) efficiently and accurately//",
    "// While suing it Make sure that you would take input as Unsigned readi,readu//",
    "bool dmr64(u64 n) {",
    "	if (n < 2) return false;",
    "	for (u64 p : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37})",
    "		if (n % p == 0) return n == p;",
    "	u64 d = n - 1;",
    "	int s = 0;",
    "	while ((d & 1) == 0) d >>= 1, ++s;",
    "",
    "	auto binpower = [](u64 base, u64 e, u64 mod) {",
    "		u64 res = 1;",
    "		base %= mod;",
    "		while (e) {",
    "			if (e & 1) res = (__uint128_t(res) * base) % mod;",
    "			base = (__uint128_t(base) * base) % mod;",
    "			e >>= 1;",
    "		}",
    "		return res;",
    "	};",
    "",
    "	for (u64 a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {",
    "		if (a >= n) break;",
    "		u64 x = binpower(a, d, n);",
    "		if (x == 1 || x == n - 1) continue;",
    "		bool composite = true;",
    "		for (int r = 1; r < s; ++r) {",
    "			x = (__uint128_t(x) * x) % n;",
    "			if (x == n - 1) {",
    "				composite = false;",
    "				break;",
    "			}",
    "		}",
    "		if (composite) return false;",
    "	}",
    "	return true;",
    "}",
    "",
    "",
    "vector<u64> factorise(u64 n) {",
    "	/*",
    "		factorises integers 1 <= n <= 2^62",
    "		bad cases: all prime factors are large",
    "		very bad cases:",
    "			1e18: 999995891929828291, 3 times worse than other bad cases",
    "			2^62: 4611653436861561323, 7 times worse than other bad cases",
    "			    = 0x3fffe25e0357b9eb",
    "	*/",
    "	vector<u64> pf;",
    "	for (u8 i : {2, 3, 5}) while (!(n % i)) pf.push_back(i), n /= i;",
    "	for (u16 i = 7; i * i <= n && i <= 211; i += 6) for (u16 j : {0, 4})",
    "		while (n % (i + j) == 0) pf.push_back(i + j), n /= i + j;",
    "	if (n == 1) return pf;",
    "	vector<u64> q{n};",
    "	while (!q.empty()) {",
    "		n = q.back(); q.pop_back();",
    "		if (n < 49729) {pf.push_back(n); continue;}",
    "		u64 r = sqrt(n) + 0.5;",
    "		if (r * r == n) {q.resize(q.size() + 2, r); continue;}",
    "		if (dmr64(n)) {pf.push_back(n); continue;}",
    "		u64 g = n, ni = -n; for (u8 _ = 5; _--;) ni *= 2 + ni * n;",
    "		auto redc = [n, ni](u128 x) -> u64 {",
    "			return u64(x) * ni * u128(n) + x >> 64;",
    "		};",
    "		auto f = [n, ni, redc](u64 x) {return redc(u128(x) * x + 1);};",
    "		const u64 m = sqrt(r + 1000) / 20;",
    "		for (u64 x0 = 0; g == n; ++x0) {",
    "			u64 x, y = x0, q = g = 1, ys;",
    "			for (u64 r = 1; g == 1; r <<= 1) {",
    "				x = y;",
    "				for (u64 _ = r; _--;) y = f(y);",
    "				for (u64 k = 0; k < r && g == 1; k += m) {",
    "					ys = y;",
    "					for (u64 _ = min(m, r - k); _--;)",
    "						y = f(y), q = redc(u128(max(x, y) - min(x, y)) * q);",
    "					g = gcd(q, n);",
    "				}",
    "			}",
    "			if (g == n) for (g = 1; g == 1;)",
    "				ys = f(ys), g = gcd(max(x, ys) - min(x, ys), n);",
    "		}",
    "		q.push_back(g); q.push_back(n / g);",
    "	}",
    "	sort(pf.begin(), pf.end());",
    "	return pf;",
    "}",
    "#define endl '\\n'"
  ],
  "description": "Use it for Factorize Unsigned Number very fast"
},
"Brent-Factor": {
  "prefix": "BrentFactor",
  "body": [
    "uint64_t brent_factor(uint64_t n){",
    "        //It returns a Non - trivial Factors, like it uses pseudo random function to generate and keeps on checking as it is highly efficient //",
    "	uint64_t r = sqrt(n) + 0.5;",
    "	if (r * r == n){",
    "		return r;",
    "	}",
    "	uint64_t g = n, ni = -n; for(uint8_t _ = 5; _--; ) ni *= 2 + ni * n;",
    " ",
    "	auto redc = [n, ni](__uint128_t x) -> uint64_t {",
    "		return uint64_t(x) * ni * __uint128_t(n) + x >> 64;",
    "	};",
    "	auto f = [n, ni, redc](uint64_t x) {return redc(__uint128_t(x) * x + 1);};",
    " ",
    " ",
    "	const uint64_t m = sqrt(r + 1000) / 20;",
    "	for (uint64_t x0 = 0; g == n; ++x0) {",
    "		uint64_t x, y = x0, q = g = 1, ys;",
    "		for (uint64_t r = 1; g == 1; r <<= 1) {",
    "			x = y;",
    "			for (uint64_t _ = r; _--;) y = f(y);",
    "			for (uint64_t k = 0; k < r && g == 1; k += m) {",
    "				ys = y;",
    "				for (uint64_t _ = min(m, r - k); _--;)",
    "					y = f(y), q = redc(__uint128_t(max(x, y) - min(x, y)) * q);",
    "				g = gcd(q, n);",
    "			}",
    "		}",
    "		if (g == n) for (g = 1; g == 1;)",
    "			ys = f(ys), g = gcd(max(x, ys) - min(x, ys), n);",
    "	}",
    "	return g;",
    "}"
  ],
  "description": "Use it as Brent Factor"
},
"": {
  "prefix": "XDict",
  "body": [
    "// Generic XDict implementation",
    "template<typename Key, typename Value>",
    "class XDict {",
    "private:",
    "    unordered_map<Key, Value, custom_hash> d;",
    "",
    "    // Optional custom transform function",
    "    Key transform(const Key& key) const {",
    "        return key; // Change this if you need transformations like lowercasing strings etc.",
    "    }",
    "",
    "public:",
    "    void set(const Key& key, const Value& value) {",
    "        d[transform(key)] = value;",
    "    }",
    "",
    "    Value get(const Key& key, const Value& def = Value()) const {",
    "        auto it = d.find(transform(key));",
    "        return it != d.end() ? it->second : def;",
    "    }",
    "",
    "    void remove(const Key& key) {",
    "        d.erase(transform(key));",
    "    }",
    "",
    "    bool contains(const Key& key) const {",
    "        return d.find(transform(key)) != d.end();",
    "    }",
    "",
    "    void clear() {",
    "        d.clear();",
    "    }",
    "",
    "    vector<Key> keys() const {",
    "        vector<Key> result;",
    "        for (const auto& p : d) result.push_back(p.first);",
    "        return result;",
    "    }",
    "",
    "    vector<Value> values() const {",
    "        vector<Value> result;",
    "        for (const auto& p : d) result.push_back(p.second);",
    "        return result;",
    "    }",
    "",
    "    vector<pair<Key, Value>> items() const {",
    "        vector<pair<Key, Value>> result;",
    "        for (const auto& p : d) result.push_back(p);",
    "        return result;",
    "    }",
    "",
    "    friend ostream& operator<<(ostream& os, const XDict& xd) {",
    "        os << \"{\";",
    "        bool first = true;",
    "        for (const auto& p : xd.d) {",
    "            if (!first) os << \", \";",
    "            os << p.first << \": \" << p.second;",
    "            first = false;",
    "        }",
    "        os << \"}\";",
    "        return os;",
    "    }",
    "};"
  ],
  "description": "XDictionary Implementation"
},
"": {
  "prefix": "BFastIO",
  "body": [
    "namespace IO {",
    "    const int BUFFER_SIZE = 1 << 15;",
    "    char input_buffer[BUFFER_SIZE];",
    "    int input_pos = 0, input_len = 0;",
    "    char output_buffer[BUFFER_SIZE];",
    "    int output_pos = 0;",
    "    char number_buffer[100];",
    "    uint8_t lookup[100];",
    "    void _update_input_buffer() {",
    "        input_len = fread(input_buffer, sizeof(char), BUFFER_SIZE, stdin);",
    "        input_pos = 0;",
    "        if (input_len == 0)",
    "            input_buffer[0] = EOF;",
    "    }",
    " ",
    "    inline char next_char(bool advance = true) {",
    "        if (input_pos >= input_len)",
    "            _update_input_buffer();",
    " ",
    "        return input_buffer[advance ? input_pos++ : input_pos];",
    "    }",
    " ",
    "    template<typename T>",
    "        inline void read_int(T &number) {",
    "            bool negative = false;",
    "            number = 0;",
    " ",
    "            while (!isdigit(next_char(false)))",
    "                if (next_char() == '-')",
    "                    negative = true;",
    " ",
    "            do {",
    "                number = 10 * number + (next_char() - '0');",
    "            } while (isdigit(next_char(false)));",
    " ",
    "            if (negative)",
    "                number = -number;",
    "        }",
    " ",
    "    template<typename T, typename... Args>",
    "        inline void read_int(T &number, Args &... args) {",
    "            read_int(number);",
    "            read_int(args...);",
    "        }",
    " ",
    "    void _flush_output() {",
    "        fwrite(output_buffer, sizeof(char), output_pos, stdout);",
    "        output_pos = 0;",
    "    }",
    " ",
    "    inline void write_char(char c) {",
    "        if (output_pos == BUFFER_SIZE)",
    "            _flush_output();",
    " ",
    "        output_buffer[output_pos++] = c;",
    "    }",
    " ",
    "    inline void write_string(string s){",
    "        for(auto e: s) ",
    "            write_char(e);",
    "    }",
    " ",
    "    template<typename T>",
    "        inline void write_int(T number, char after = '\\0') {",
    "            if (number < 0) {",
    "                write_char('-');",
    "                number = -number;",
    "            }",
    "            int length = 0;",
    "            while (number >= 10) {",
    "                uint8_t lookup_value = lookup[number % 100];",
    "                number /= 100;",
    "                number_buffer[length++] = (lookup_value & 15) + '0';",
    "                number_buffer[length++] = (lookup_value >> 4) + '0';",
    "            }",
    "            if (number != 0 || length == 0)",
    "                write_char(number + '0');",
    "            for (int i = length - 1; i >= 0; i--)",
    "                write_char(number_buffer[i]);",
    "            if (after)",
    "                write_char(after);",
    "        }",
    " ",
    "    void IOinit() {",
    "        // Make sure _flush_output() is called at the end of the program.",
    "        bool exit_success = atexit(_flush_output) == 0;",
    "        assert(exit_success);",
    "        for (int i = 0; i < 100; i++)",
    "            lookup[i] = (i / 10 << 4) + i % 10;",
    "    }",
    "}",
    " ",
    "using namespace IO;",
    "//Make sure to take input as read_int(x)",
    "//if you are taking vector input the for(auto &e:a)read_int(e)"
  ],
  "description": "It is Beginner Fast I/O technique"
}
,
"Pragmas": {
  "prefix": "Pragma",
  "body": [
    "#pragma GCC optimize(\"Ofast\")",
    "#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,popcnt,abm,mmx\")",
    ""
  ],
  "description": "Use It Whenevr You think time is playing critical role in certain Code"
}
,
"Z-Algorithm": {
  "prefix": "Z-Algorithm",
  "body": [
"template <typename Sequence>",
    "struct ZAlgorithm {",
    "    using value_type = typename Sequence::value_type;",
    "    using size_type = uint32_t;",
    "",
    "    Sequence m_pattern;           // The stored pattern used to compute Z-array.",
    "    std::vector<size_type> m_z;   // The Z-array itself.",
    "",
    "    ZAlgorithm() = default;",
    "",
    "    // Constructor: initialize with size and a function mapping i -> element",
    "    // Usage:",
    "    // ZAlgorithm<vector<int>> z(len, [&](int i) { return my_sequence[i]; });",
    "    // Time Complexity: O(n)",
    "    template <typename InitMapping>",
    "    ZAlgorithm(size_type length, InitMapping mapping) {",
    "        resize(length, mapping); ",
    "    }",
    "",
    "    // Constructor: initialize from iterators",
    "    // Usage:",
    "    // ZAlgorithm<vector<int>> z(v.begin(), v.end());",
    "    // Time Complexity: O(n)",
    "    template <typename Iterator>",
    "    ZAlgorithm(Iterator first, Iterator last) {",
    "        reset(first, last);",
    "    }",
    "",
    "    // Constructor: initialize directly from a sequence",
    "    // Usage:",
    "    // vector<int> v = {...}; ZAlgorithm<vector<int>> z(v);",
    "    // Time Complexity: O(n)",
    "    ZAlgorithm(const Sequence& seq)",
    "        : ZAlgorithm(std::begin(seq), std::end(seq)) {}",
    "",
    "    // Reset or resize the internal pattern and compute Z-array",
    "    // Useful for reusing a single ZAlgorithm instance.",
    "    // Time Complexity: O(n)",
    "    template <typename InitMapping>",
    "    void resize(size_type length, InitMapping mapping) {",
    "        m_pattern.clear();",
    "        m_pattern.reserve(length); ",
    "        for (size_type i = 0; i < length; ++i)",
    "            m_pattern.push_back(mapping(i)); ",
    "        build_z_array(length, m_pattern.begin()); ",
    "    }",
    "",
    "    // Reset with a new pattern using iterators",
    "    // Usage:",
    "    // z.reset(v.begin(), v.end());",
    "    // Time Complexity: O(n)",
    "    template <typename Iterator>",
    "    void reset(Iterator first, Iterator last) {",
    "        m_pattern.assign(first, last); ",
    "        size_type length = static_cast<size_type>(std::distance(first, last));",
    "        build_z_array(length, m_pattern.begin());",
    "    }",
    "",
    "    // Checks whether the stored pattern exists fully within the given range [first, last)",
    "    // Returns the starting index of the first match, or -1 if not found",
    "    // Usage:",
    "    // if (z.contained_by(text.begin(), text.end()) != -1) { ... }",
    "    // Time Complexity: O(n·m) in worst-case (inefficient for large ranges)",
    "    template <typename Iterator>",
    "    int32_t contained_by(Iterator first, Iterator last) const {",
    "        if (m_z.empty()) return -1;",
    "",
    "        size_type pattern_len = static_cast<size_type>(m_pattern.size());",
    "        size_type len = static_cast<size_type>(std::distance(first, last));",
    "",
    "        if (pattern_len > len) return -1;",
    "",
    "        size_type l = static_cast<size_type>(-1), r = static_cast<size_type>(-1);",
    "        for (size_type i = 0; i + pattern_len <= len; ++i) {",
    "            if (adjust(l, r, i, len, first) == pattern_len)",
    "                return static_cast<int32_t>(i);",
    "        }",
    "        return -1;",
    "    }",
    "",
    "    // Query Z[i] = length of longest prefix starting at i that matches the pattern prefix",
    "    // Only valid after resize/reset is called.",
    "    // Usage:",
    "    // z.query_Z(i); ",
    "    // Time Complexity: O(1)",
    "    size_type query_Z(size_type i) const {",
    "        assert(i < m_z.size());",
    "        return m_z[i];",
    "    }",
    "",
    "private:",
    "    // Build the Z-array from pattern starting at given iterator",
    "    // Time Complexity: O(n)",
    "    template <typename Iterator>",
    "    void build_z_array(size_type length, Iterator iter) {",
    "        m_z.clear();",
    "        m_z.reserve(length);",
    "        m_z.push_back(0); // Z[0] is always 0 by convention",
    "",
    "        size_type l = 0, r = 0;",
    "        for (size_type i = 1; i < length; ++i)",
    "            m_z.push_back(adjust(l, r, i, length, iter));",
    "    }",
    "",
    "    // Core Z-algorithm adjust logic used to fill Z[i]",
    "    // Calculates Z[i] in amortized constant time.",
    "    // Time Complexity: O(1) amortized per call",
    "    template <typename Ptr, typename Iterator>",
    "    size_type adjust(Ptr& l, Ptr& r, Ptr i, const size_type& length, const Iterator& iter) const {",
    "        // Case 1: i is within [l, r], reuse previously computed Z values",
    "        if (~r && i <= r && m_z[i - l] < r - i + 1)",
    "            return m_z[i - l];",
    "        // Case 2: i is outside, and first character doesn't match pattern",
    "        else if (iter[i] != m_pattern[0])",
    "            return 0;",
    "        // Case 3: Recompute Z[i] by comparing characters",
    "        l = i;",
    "        if (!~r || r < i) r = i;",
    "        while (r + 1 < length && iter[r + 1] == m_pattern[r + 1 - i])",
    "            ++r;",
    "        return r - i + 1;",
    "    }",
    "};",
    ""
  ],
  "description": "Use It for Z-Algorithm Class Implementation"
}
,
"Z-Function": {
  "prefix": "Z-Func",
  "body": [
    "vector<int> z_function(string s) {",
    "    int n = s.size();",
    "    vector<int> z(n);",
    "    int l = 0, r = 0;",
    "    for(int i = 1; i < n; i++) {",
    "        if(i < r) {",
    "            z[i] = min(r - i, z[i - l]);",
    "        }",
    "        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
    "            z[i]++;",
    "        }",
    "        if(i + z[i] > r) {",
    "            l = i;",
    "            r = i + z[i];",
    "        }",
    "    }",
    "    return z;",
    "}"
  ],
  "description": " Same as Z-Algorithm but with No class"
},
"Modular_Int": {
  "prefix": "modular_int",
  "body": [
    "template<const int MOD>",
    "struct modular_int{",
    "	int x;",
    "	static vector<int> inverse_list ;",
    "	const static int inverse_limit;",
    "	const static bool is_prime;",
    "	modular_int(){",
    "		x = 0;",
    "	}",
    "	template<typename T>  ",
    "	modular_int(const T z){",
    "		x = (z%MOD);",
    "		if (x < 0) x += MOD; 	",
    "	}",
    "	modular_int(const modular_int<MOD>* z){",
    "		x = z->x;",
    "	}",
    "	modular_int(const modular_int<MOD>& z){",
    "		x = z.x;",
    "	}",
    "    modular_int& operator++() { return *this += 1; }",
    "    modular_int& operator--() { return *this -= 1; }",
    "    modular_int operator++(int) { modular_int tmp = *this; *this += 1; return tmp; }",
    "    modular_int operator--(int) { modular_int tmp = *this; *this -= 1; return tmp; }",
    "	modular_int operator - (const modular_int<MOD>& m) const{",
    "		modular_int<MOD> U;",
    "		U.x = x - m.x;",
    "		if (U.x < 0) U.x += MOD;",
    "		return U;",
    "	}",
    "	modular_int operator + (const modular_int<MOD>& m) const{",
    "		modular_int<MOD> U;",
    "		U.x = x + m.x;",
    "		if (U.x >= MOD) U.x -= MOD;",
    "		return U;",
    "	}",
    "	modular_int& operator -= (const modular_int<MOD>& m){",
    "		x -= m.x;",
    "		if (x < 0) x += MOD;",
    "		return *this;",
    "	}	",
    "	modular_int& operator += (const modular_int<MOD>& m){",
    "		x += m.x;",
    "		if (x >= MOD) x -= MOD;",
    "		return *this;",
    "	}	",
    "	modular_int operator * (const modular_int<MOD>& m) const{",
    "		modular_int<MOD> U;",
    "		U.x = (x* 1ull * m.x) %MOD;",
    "		return U;",
    "	}",
    "	modular_int& operator *= (const modular_int<MOD>& m){",
    "		x = (x * 1ull * m.x)%MOD;",
    "		return *this;",
    "	}",
    "	template<typename T>",
    "	friend modular_int operator + (const T &l, const modular_int<MOD>& p){",
    "		return (modular_int<MOD>(l) + p);",
    "	}",
    "	template<typename T>",
    "	friend modular_int operator - (const T &l, const modular_int<MOD>& p){",
    "		return (modular_int<MOD>(l) - p);",
    "	}",
    "	template<typename T>",
    "	friend modular_int operator * (const T &l, const modular_int<MOD>& p){",
    "		return (modular_int<MOD>(l) * p);",
    "	}",
    "	template<typename T>",
    "	friend modular_int operator / (const T &l, const modular_int<MOD>& p){",
    "		return (modular_int<MOD>(l) / p);",
    "	}",
    " ",
    "	int value() const{",
    "		return x;",
    "	}",
    " ",
    "	modular_int operator ^ (const modular_int<MOD>& cpower) const{",
    "		modular_int<MOD> ans;",
    "		ans.x = 1;",
    "		modular_int<MOD> curr(this);",
    "		int power = cpower.x;",
    " ",
    "		if (curr.x <= 1){",
    "			if (power == 0) curr.x = 1;",
    "			return curr;",
    "		}",
    "		while( power > 0){",
    "			if (power&1){",
    "				ans *= curr;",
    "			}",
    "			power >>= 1;",
    "			if (power) curr *= curr;",
    "		}",
    "		return ans;",
    "	}",
    " ",
    " ",
    "	modular_int operator ^ (long long power) const{",
    "		modular_int<MOD> ans;",
    "		ans.x = 1;",
    "		modular_int<MOD> curr(this);",
    "		if (curr.x <= 1){",
    "			if (power == 0) curr.x = 1;",
    "			return curr;",
    "		}",
    "		// Prime Mods",
    "		if (power >= MOD && is_prime){",
    "			power %= (MOD - 1);",
    "		}",
    " ",
    "		while( power > 0){",
    "			if (power&1){",
    "				ans *= curr;",
    "			}",
    "			power >>= 1;",
    "			if (power) curr *= curr;",
    " ",
    "		}",
    "		return ans;",
    "	}",
    " ",
    "	modular_int operator ^ (int power) const{",
    "		modular_int<MOD> ans;",
    "		ans.x = 1;",
    "		modular_int<MOD> curr(this);",
    "		",
    "		if (curr.x <= 1){",
    "			if (power == 0) curr.x = 1;",
    "			return curr;",
    "		}",
    "		while( power > 0){",
    "			if (power&1){",
    "				ans *= curr;",
    "			}",
    "			power >>= 1;",
    "			if (power) curr *= curr;",
    " ",
    "		}",
    "		return ans;",
    "	}",
    "	",
    "	template<typename T>",
    "	modular_int& operator ^= (T power) {",
    "		modular_int<MOD> res = (*this)^power;",
    "		x = res.x;",
    "		return *this;",
    "	}",
    " ",
    " ",
    "	template<typename T>",
    "	modular_int pow(T x){",
    "		return (*this)^x;",
    "	}",
    " ",
    "	",
    "	pair<long long,long long> gcd(const int a, const int b) const {",
    "		if (b==0) return {1,0}; ",
    "		pair<long long,long long> c = gcd(b , a%b);",
    "		return { c.second , c.first - (a/b)*c.second}; ",
    "	}",
    " ",
    "	inline void init_inverse_list() const {",
    "		vector<int>& dp = modular_int<MOD>::inverse_list;",
    "		dp.resize(modular_int<MOD>::inverse_limit + 1);",
    "		int n = modular_int<MOD>::inverse_limit;",
    "		dp[0] = 1;",
    "		if (n > 1) dp[1] = 1;",
    "		for(int i = 2; i <= n; ++i){",
    "			dp[i] = (dp[MOD%i] * 1ull *(MOD - MOD/i))%MOD;",
    "		}",
    "	",
    "	}",
    "	modular_int<MOD> get_inv() const {",
    "		if (modular_int<MOD>::inverse_list.size() < modular_int<MOD>::inverse_limit + 1) init_inverse_list();",
    " ",
    "		if (this->x <= modular_int<MOD>::inverse_limit){",
    "			return modular_int<MOD>::inverse_list[this->x];",
    "		}",
    "		pair<long long,long long> G = gcd(this->x,MOD);",
    "		return modular_int<MOD>(G.first);",
    "	}",
    "	modular_int<MOD> operator - () const {",
    "		modular_int<MOD> v(0);",
    "		v -= (*this);",
    "		return v;",
    "	}",
    "	modular_int operator / (const modular_int<MOD>& m) const{",
    "		modular_int<MOD> U(this);",
    "		U *= m.get_inv();",
    "		return U;",
    "	}",
    "	modular_int& operator /= (const modular_int<MOD>& m){",
    "		(*this) *= m.get_inv();",
    "		return *this;",
    "	}",
    "	bool operator==(const modular_int<MOD>& m) const{",
    "		return x == m.x;",
    "	}",
    " ",
    "	bool operator < (const modular_int<MOD>& m) const {",
    "		return x < m.x;",
    "	}",
    " ",
    " ",
    "	template<typename T>",
    "	bool operator == (const T& m) const{",
    "		return (*this)== (modular_int<MOD>(m));",
    "	}",
    " ",
    "	template<typename T>",
    "	bool operator < (const T& m) const {",
    "		return x < (modular_int<MOD>(m)).x;",
    "	}",
    "	template<typename T>",
    "	bool operator > (const T& m) const {",
    "		return x > (modular_int<MOD>(m)).x;",
    "	}",
    "	template<typename T>",
    "	friend bool operator == (const T& x, const modular_int<MOD>& m) {",
    "		return (modular_int<MOD>(x)).x == m.x;",
    "	}",
    "	template<typename T> ",
    "	friend bool operator < (const T& x, const modular_int<MOD>& m){",
    "		return (modular_int<MOD>(x)).x < m.x;",
    "	}",
    "	template<typename T> ",
    "	friend bool operator > (const T& x, const modular_int<MOD>& m){",
    "		return (modular_int<MOD>(x)).x > m.x;",
    "	}",
    " ",
    "	friend istream& operator >> (istream& is, modular_int<MOD>& p){",
    "		int64_t val;",
    "		is >> val;",
    "		p.x = (val%MOD);",
    "		if (p.x < 0) p.x += MOD;",
    "		return is;",
    "	}",
    "	friend ostream& operator << (ostream& os, const modular_int<MOD>& p) {return os<<p.x;}",
    " ",
    " ",
    " ",
    "};",
    " ",
    " ",
    "const int mod = 1e9 + 7;",
    " ",
    "using mint = modular_int<mod>;",
    "template<const int MOD>",
    "vector<int> modular_int<MOD>::inverse_list ;",
    "template<const int MOD>",
    "const int modular_int<MOD>::inverse_limit = -1;",
    "template<const int MOD>",
    "const bool modular_int<MOD>::is_prime = true;",
    "// template<>   //-> useful if computing inverse fact = i_f[i-1] / i;",
    "// const int modular_int<mod>::inverse_limit = 100000;",
    "const int MAXF = 1 << 20;",
    "vector<mint> fact(MAXF), ifact(MAXF);",
    "void init_factorials() {",
    "    fact[0] = 1;",
    "    for (int i = 1; i < MAXF; i++) fact[i] = fact[i-1] * i;",
    "    ifact[MAXF - 1] = fact[MAXF - 1].get_inv();",
    "    for (int i = MAXF - 2; i >= 0; i--) ifact[i] = ifact[i+1] * (i+1);",
    "}",
    "mint C(int n, int k) {",
    "    if (k < 0 || k > n) return 0;",
    "    return fact[n] * ifact[k] * ifact[n - k];",
    "}"
  ],
  "description": "Use it For all the Modular Integer computation"
},
"GP-Hash_Table": {
  "prefix":"gp_hash",
  "body": [
    "using uint64 = uint64_t;",
    "",
    "// High-quality randomized hash suitable for Codeforces and other environments",
    "struct chash {",
    "    static uint64_t splitmix64(uint64_t x) {",
    "        x += 0x9e3779b97f4a7c15;",
    "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
    "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
    "        return x ^ (x >> 31);",
    "    }",
    "",
    "    static const uint64_t FIXED_RANDOM;",
    "",
    "    template<typename T>",
    "    size_t operator()(T x) const {",
    "        return splitmix64(static_cast<uint64_t>(x) + FIXED_RANDOM);",
    "    }",
    "",
    "    template<typename T, typename U>",
    "    size_t operator()(const pair<T, U>& p) const {",
    "        uint64_t h1 = operator()(p.first);",
    "        uint64_t h2 = operator()(p.second);",
    "        return splitmix64(h1 ^ (h2 << 1));",
    "    }",
    "",
    "    template<typename... Args>",
    "    size_t operator()(const tuple<Args...>& t) const {",
    "        return hash_tuple(t);",
    "    }",
    "",
    "private:",
    "    // Recursive hash for tuple",
    "    template<size_t Index = 0, typename... Types>",
    "    typename enable_if<Index == sizeof...(Types), size_t>::type",
    "    static hash_tuple_impl(const tuple<Types...>&) {",
    "        return 0;",
    "    }",
    "",
    "    template<size_t Index = 0, typename... Types>",
    "    typename enable_if<Index < sizeof...(Types), size_t>::type",
    "    static hash_tuple_impl(const tuple<Types...>& t) {",
    "        chash h;",
    "        size_t cur = h(get<Index>(t));",
    "        size_t rest = hash_tuple_impl<Index + 1>(t);",
    "        return splitmix64(cur ^ (rest << 1));",
    "    }",
    "",
    "    template<typename... Types>",
    "    static size_t hash_tuple(const tuple<Types...>& t) {",
    "        return hash_tuple_impl(t);",
    "    }",
    "};",
    "",
    "// Initialize the random seed once globally",
    "const uint64_t chash::FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
    "",
    "// Usage:",
    "gp_hash_table<pair<int, int>, int, chash> pair_map({},{},{},{},{1 << 16});",
    "gp_hash_table<tuple<int, int, int>, int, chash> tuple_map({},{},{},{},{1 << 16});",
    "gp_hash_table<ll, int, chash> int_map({},{},{},{},{1 << 16});"
  ],
  "description": "Use it for the Best Implementation of GP Hash-Table"
}
,
"Segment Tree with point Updates(Advanced)": {
  "prefix": "SegPoint Adv",
  "body": [
    "template<typename Node>",
    "class SegmentTree{",
    "private:",
    "    int n;",
    "    std::vector<Node>tree;",
    "",
    "    template <typename F>",
    "    int find_first_knowingly(int i,F pred,Node& cur){",
    "        while(i<n){",
    "            Node tmp;",
    "            tmp.unite(cur,tree[i<<1]);",
    "            if(pred(tmp)){",
    "                i = i << 1;",
    "            }else{",
    "                cur=tmp;",
    "                i=i<<1 | 1;",
    "            }",
    "        }",
    "        return i-n;",
    "    }",
    "",
    "    template<typename F>",
    "    int find_last_knowingly(int i,F pred,Node& cur){",
    "        while(i<n){",
    "            Node tmp;",
    "            tmp.unite(tree[i<<1 | 1],cur);",
    "            if(pred(tmp)){",
    "                i=i<<1 | 1;",
    "            }else{",
    "                cur=tmp;",
    "                i=i<<1;",
    "            }",
    "        }",
    "        return i-n;",
    "    }",
    "",
    "    template<typename T,typename Compare>",
    "    int find_kth(int node,int node_l,int node_r,T k,Compare comp){",
    "        if(node_l==node_r)return node_l;",
    "        int mid=(node_l + node_r)/2;",
    "        if(comp(tree[2*node].sum,k)) {",
    "            return find_kth(2*node+1,mid+1,node_r,k-tree[2*node].sum,comp);",
    "        } else {",
    "            return find_kth(2*node,node_l,mid,k,comp);",
    "        }",
    "    }",
    "",
    "public:",
    "    SegmentTree(int _n):n(_n){",
    "        assert(n>0);",
    "        tree.resize(2*n);",
    "        for(int i=0;i<2*n;++i)",
    "            tree[i]=Node();",
    "    }",
    "",
    "    template<typename M>",
    "    SegmentTree(const std::vector<M>& v) {",
    "        n=v.size();",
    "        assert(n>0);",
    "        tree.resize(2*n);",
    "        for(int i=0;i<n;++i)",
    "            tree[n+i].apply(i,i,v[i]);",
    "        for(int i=n-1;i>0;--i)",
    "            tree[i].unite(tree[i<<1],tree[i<<1 | 1]);",
    "    }",
    "",
    "    Node get(int l,int r){",
    "        assert(0<=l && l<=r && r<n);",
    "        Node res_left,res_right;",
    "        for(l+=n,r+=n+1;l<r;l>>=1,r>>= 1) {",
    "            if(l & 1) res_left.unite(res_left,tree[l++]);",
    "            if(r & 1) res_right.unite(tree[--r],res_right);",
    "        }",
    "        res_left.unite(res_left,res_right);",
    "        return res_left;",
    "    }",
    "",
    "    Node get(int p){",
    "        assert(0<=p && p<n);",
    "        return tree[p+n];",
    "    }",
    "",
    "    template<typename... M>",
    "    void modify(int p,const M&... v){",
    "        assert(0<=p && p<n);",
    "        tree[p+=n].apply(p,p,v...);",
    "        for(p>>=1;p>0;p>>= 1)",
    "            tree[p].unite(tree[p<<1], tree[p<<1 | 1]);",
    "    }",
    "",
    "    template<typename F>",
    "    void update_with_func(int p, F func){",
    "        assert(0<=p && p<n);",
    "        p+=n;",
    "        tree[p].apply(p-n,p-n,func(tree[p]));",
    "        for(p>>=1;p>0;p>>=1)",
    "            tree[p].unite(tree[p<<1],tree[p<<1 | 1]);",
    "    }",
    "",
    "    template<typename F>",
    "    int find_first(int l,F pred){",
    "        Node cur;",
    "        if(l>=n)return -1;",
    "        int r=2*n;",
    "        for(l+=n;l<r;l>>=1,r>>=1) {",
    "            if(l&1){",
    "                Node tmp;",
    "                tmp.unite(cur,tree[l]);",
    "                if(pred(tmp))return find_first_knowingly(l,pred,cur);",
    "                cur.unite(cur,tree[l++]);",
    "            }",
    "        }",
    "        return -1;",
    "    }",
    "",
    "    template<typename F>",
    "    int find_last(int r, F pred){",
    "        Node cur;",
    "        if(r<0)return -1;",
    "        for(int l=n,r0=r+1+n;l<r0;l>>=1,r0>>=1){",
    "            if(r0&1){",
    "                --r0;",
    "                Node tmp;",
    "                tmp.unite(tree[r0],cur);",
    "                if(pred(tmp))return find_last_knowingly(r0,pred,cur);",
    "                cur.unite(tree[r0],cur);",
    "            }",
    "        }",
    "        return -1;",
    "    }",
    "",
    "    template<typename T>",
    "    int lower_bound(T value){",
    "        if(value<=0)return 0;",
    "        int pos=1;",
    "        T sum=0;",
    "        while(pos<n){",
    "            if(sum + tree[pos<<1].sum<value){",
    "                sum+=tree[pos<<1].sum;",
    "                pos=pos<<1 | 1;",
    "            }else{",
    "                pos=pos<<1;",
    "            }",
    "        }",
    "        return pos-n;",
    "    }",
    "",
    "    template<typename T>",
    "    int upper_bound(T value){",
    "        int pos=1;",
    "        T sum=0;",
    "        while(pos<n){",
    "            if(sum + tree[pos<<1].sum<=value){",
    "                sum+=tree[pos<<1].sum;",
    "                pos=pos<<1 | 1;",
    "            }else{",
    "                pos=pos<<1;",
    "            }",
    "        }",
    "        return pos-n;",
    "    }",
    "",
    "    // Find k-th smallest element (1-based)",
    "    // Requires Node to have 'sum' member and support operator<",
    "    template<typename T = long long>",
    "    int kth_smallest(T k){",
    "        static_assert(std::is_same<decltype(Node().sum), T>::value, ",
    "                     \"Node must have 'sum' member of type T\");",
    "        return find_kth(1,0,n-1,k,std::less<T>());",
    "    }",
    "",
    "    // Find k-th largest element (1-based)",
    "    // Requires Node to have 'sum' member and support operator<",
    "    template<typename T = long long>",
    "    int kth_largest(T k){",
    "        static_assert(std::is_same<decltype(Node().sum), T>::value, ",
    "                     \"Node must have 'sum' member of type T\");",
    "        T total=tree[1].sum;",
    "        return find_kth(1,0,n-1,total-k+1,std::less<T>());",
    "    }",
    "    ",
    "    ",
    "    double median(){",
    "        long long total = tree[1].sum;",
    "        if (total==0) return 0; // or throw exception for empty set",
    "",
    "        if (total%2==1){",
    "            // odd → single middle",
    "            return kth_smallest((total+1)/2);",
    "        } else {",
    "            // even → average of two middle elements",
    "            int left=kth_smallest(total/2);",
    "            int right=kth_smallest(total / 2 + 1);",
    "            return (left+right)/2.0;",
    "        }",
    "    }",
    "",
    "",
    "    void print(bool full = false, bool treeView = false, std::ostream& out = std::cerr) const {",
    "        out << \"\\n==== Segment Tree Debug ====\\n\";",
    "        out << \"Array size (n): \" << n << \"\\n\\n\";",
    "        if (!treeView) {",
    "            out << \"Leaf Nodes:\\n\";",
    "            for (int i = 0; i < n; ++i)",
    "                out << \"[\" << i << \"] = \" << tree[i + n] << \"\\n\";",
    "            if (full) {",
    "                out << \"\\nInternal Nodes:\\n\";",
    "                for (int i = 1; i < n; ++i)",
    "                    out << \"[\" << i << \"] = \" << tree[i] << \"\\n\";",
    "            }",
    "        } else {",
    "            int level = 0, width = 1, idx = 1;",
    "            while (idx < 2 * n) {",
    "                out << \"Level \" << level << \": \";",
    "                for (int j = 0; j < width && idx < 2 * n; ++j, ++idx)",
    "                    out << (idx < n ? \"[I\" : \"[L\") << (idx < n ? idx : idx - n) << \":\" << tree[idx] << \"] \";",
    "                out << \"\\n\";",
    "                width <<= 1;",
    "                ++level;",
    "            }",
    "        }",
    "        out << \"============================\\n\\n\";",
    "    }",
    "",
    "    //segtree<node> st({1, 2, 3, 4, 5});",
    "    //st.print();              // leaf nodes only",
    "    //st.print(true);          // full flat display",
    "    //st.print(true, true);    // tree-like view",
    "};",
    "//To Use Update with Functions(Modify index i with custom lambda)",


    "//st.update_with_func(3, [](Node x) { return x + 7; });",
    "//For Search Queries",
    " ",
    "//int find_first(int l,F pred)",
    "//->Finds the smallest index i ≥ l such that pred(get(l, i)) == true.",
    "//->Usage:int idx = st.find_first(0, [](Node x) { return x.sum >= 10; });",
    "",
    "//int find_last(int r, F pred)",
    "//->Finds the largest index i ≤ r such that pred(get(i, r)) == true",
    "//->Usage:int idx = st.find_last(4, [](Node x) { return x.sum >= 10; });",
    "",
    "//For Order Statistics / K-th Element",
    "",
    "//int kth_smallest(T k)",
    "//->Returns index of the k-th smallest element assuming array represents a multiset and Node.sum is count.",
    "//->Usage:int idx = st.kth_smallest(3);",
    "",
    "//int kth_largest(T k)",
    "//->Like kth_smallest but from the right (largest first).",
    "//->Usage:int idx = st.kth_largest(2);",
    "",
    "",
    "// ======================= Node Definitions =======================",
    "struct Node{",
    "    long long val=INT_MAX; //it will also change agar minimum apply krrhe to ye LLONG_MAX , else depend on situation",
    "    long long freq=0;//ye bhi add hua qn frq chahiye tha hume ",
    "",
    "    void apply(int l,int r,long long v){ //isme bhi change hota hai",
    "        val=v;//if you're using range set",
    "        freq=1;",
    "        //val(operation)=v eg. val^=v (to isse apna array jo build hoga wo bhi change hojayega) mtlb applying operation incrementally",
    "     }",
    "    void unite(const Node& a, const Node& b) { //saara change isme hi hoga and upar ke matlab bas change issi node wale me hoga",
    "         if(a.val>b.val){",
    "            val=b.val;",
    "            freq=b.freq;",
    "         }",
    "         else if(b.val>a.val){",
    "            val=a.val;",
    "            freq=a.freq;",
    "         }",
    "         else if(a.val==b.val){",
    "            val=a.val;",
    "            freq=a.freq+b.freq;",
    "         }",
    "        }",
    "    operator long long()const{return val;}",
    "    //ye friend function ko use krne ke liye auto use krna main me then auto se print krwana . use krke ",
    "    friend std::ostream& operator<<(std::ostream& out,const Node& nd){return cout<<nd.val<<\" \"<<nd.freq<<\"\\n\";}",
    "};"
  ],
  "description": "implementation of Advanced Segment Tree with Point Updates"
},
"Segment Tree with point Update (Basic)": {
  "prefix": "SegPoint Basic",
  "body": [
    "struct Node {",
    "    long long seg;  // Maximum subarray sum in the interval",
    "    long long pref; // Maximum prefix sum",
    "    long long suf;  // Maximum suffix sum",
    "    long long sum;  // Total sum of the interval",
    "",
    "    Node() : seg(0), pref(0), suf(0), sum(0) {}",
    "    ",
    "    void apply(int l, int r, long long v) {",
    "        seg = pref = suf = max(0LL, v);",
    "        sum = v;",
    "    }",
    "    ",
    "    void unite(const Node& left, const Node& right) {",
    "        sum = left.sum + right.sum;",
    "        pref = max(left.pref, left.sum + right.pref);",
    "        suf = max(right.suf, right.sum + left.suf);",
    "        seg = max({left.seg, right.seg, left.suf + right.pref});",
    "    }",
    "};",
    "",
    "template<typename Node>",
    "class SegmentTree {",
    "private:",
    "    int n;",
    "    vector<Node> tree;",
    "",
    "public:",
    "    SegmentTree(int _n) : n(_n) {",
    "        tree.resize(4 * n);",
    "    }",
    "",
    "    SegmentTree(const vector<long long>& v) {",
    "        n = v.size();",
    "        tree.resize(4 * n);",
    "        build(1, 0, n-1, v);",
    "    }",
    "",
    "    void build(int node, int node_l, int node_r, const vector<long long>& v) {",
    "        if (node_l == node_r) {",
    "            tree[node].apply(node_l, node_r, v[node_l]);",
    "            return;",
    "        }",
    "        int mid = (node_l + node_r) / 2;",
    "        build(2*node, node_l, mid, v);",
    "        build(2*node+1, mid+1, node_r, v);",
    "        tree[node].unite(tree[2*node], tree[2*node+1]);",
    "    }",
    "",
    "    void modify(int pos, long long val) {",
    "        modify(1, 0, n-1, pos, val);",
    "    }",
    "",
    "    void modify(int node, int node_l, int node_r, int pos, long long val) {",
    "        if (node_l == node_r) {",
    "            tree[node].apply(node_l, node_r, val);",
    "            return;",
    "        }",
    "        int mid = (node_l + node_r) / 2;",
    "        if (pos <= mid) {",
    "            modify(2*node, node_l, mid, pos, val);",
    "        } else {",
    "            modify(2*node+1, mid+1, node_r, pos, val);",
    "        }",
    "        tree[node].unite(tree[2*node], tree[2*node+1]);",
    "    }",
    "",
    "    Node query(int l, int r) {",
    "        return query(1, 0, n-1, l, r);",
    "    }",
    "",
    "    Node query(int node, int node_l, int node_r, int l, int r) {",
    "        if (r < node_l || node_r < l) return Node();",
    "        if (l <= node_l && node_r <= r) return tree[node];",
    "        int mid = (node_l + node_r) / 2;",
    "        Node left = query(2*node, node_l, mid, l, r);",
    "        Node right = query(2*node+1, mid+1, node_r, l, r);",
    "        Node res;",
    "        res.unite(left, right);",
    "        return res;",
    "    }",
    "};"
  ],
  "description": "Implementation of Segment Tree (Basic)"
}
}
